global:
  imageRegistry: ''  # Registro globale delle immagini Docker
  imagePullSecrets: []  # Segreti per il pull delle immagini Docker
  defaultStorageClass: ''  # Classe di storage predefinita per i volumi persistenti
  storageClass: ''  # Classe di storage (deprecata, usa defaultStorageClass)
  security:
    allowInsecureImages: false  # Consenti immagini non sicure
  compatibility:
    openshift:
      adaptSecurityContext: auto  # Adatta il contesto di sicurezza per OpenShift

kubeVersion: '1.24.0'  # Versione minima di Kubernetes richiesta
nameOverride: 'keycloak'  # Sovrascrive il nome del rilascio
fullnameOverride: 'keycloak'  # Sovrascrive il nome completo del rilascio
namespaceOverride: 'keycloak'  # Namespace del rilascio
commonLabels:  # Etichette comuni per tutte le risorse create
  app: keycloak
  component: sso
enableServiceLinks: false  # Disabilita i link ai servizi nei pod
commonAnnotations:  # Annotazioni comuni per tutte le risorse create
  prometheus.io/scrape: 'true'  # Abilita il monitoraggio Prometheus
dnsPolicy: 'ClusterFirst'  # Politica DNS per i pod
dnsConfig:  # Configurazione DNS personalizzata
  nameservers:
    - 8.8.8.8  # Nameserver personalizzato
  searches:
    - keycloak.local
clusterDomain: cluster.local  # Dominio del cluster Kubernetes
extraDeploy: []  # Oggetti Kubernetes aggiuntivi da distribuire
usePasswordFiles: true  # Usa file per le credenziali invece delle variabili di ambiente

diagnosticMode:
  enabled: false  # Abilita la modalità diagnostica
  command:
    - sleep  # Comando da eseguire in modalità diagnostica
  args:
    - infinity  # Argomenti per il comando

image:
  registry: docker.io  # Registro Docker per l'immagine di Keycloak
  repository: bitnami/keycloak  # Repository dell'immagine di Keycloak
  tag: 26.2.1-debian-12-r0  # Tag dell'immagine
  digest: ''  # Digest dell'immagine (opzionale, usalo per garantire l'integrità dell'immagine)
  pullPolicy: IfNotPresent  # Politica di pull dell'immagine
  pullSecrets: []  # Segreti per il pull dell'immagine (aggiungi solo se utilizzi un registro privato)
  debug: false  # Abilita i log di debug (imposta su true solo per scopi di debug)

auth:
  adminUser: admin  # Nome utente amministratore di Keycloak
  adminPassword: 'admin_pass'  # Password dell'amministratore
  existingSecret: ''  # Nome di un secret Kubernetes esistente per le credenziali (opzionale)
  passwordSecretKey: ''  # Chiave per la password nel secret (necessaria se usi un secret esistente)
  annotations: {}  # Annotazioni aggiuntive per il secret (opzionale)

customCaExistingSecret: ''  # Secret contenente i certificati CA personalizzati

tls:
  enabled: true  # Abilita TLS
  autoGenerated: false  # Genera automaticamente certificati self-signed
  existingSecret: keycloak.local-tls  # Secret esistente contenente i certificati TLS
  usePem: true  # Usa certificati PEM invece di JKS/PKCS12
  truststoreFilename: keycloak.truststore.jks  # Nome del truststore
  keystoreFilename: keycloak.keystore.jks  # Nome del keystore
  keystorePassword: ''  # Password del keystore
  truststorePassword: ''  # Password del truststore
  passwordsSecret: ''  # Secret contenente le password di keystore/truststore

spi:
  existingSecret: ''  # Secret esistente per il truststore SPI
  truststorePassword: ''  # Password del truststore SPI
  truststoreFilename: keycloak-spi.truststore.jks  # Nome del truststore SPI
  passwordsSecret: ''  # Secret contenente le password SPI
  hostnameVerificationPolicy: ''  # Politica di verifica del nome host

adminRealm: master  # Nome del realm amministrativo
production: true  # Esegui Keycloak in modalità produzione
proxyHeaders: 'X-Forwarded-For,X-Forwarded-Proto,X-Forwarded-Host'  # Header proxy per Keycloak
proxy: edge  # Modalità proxy (edge, reencrypt, passthrough, none)
httpRelativePath: '/'  # Percorso relativo per le risorse HTTP

configuration: ''  # Configurazione personalizzata per Keycloak
existingConfigmap: ''  # ConfigMap esistente con la configurazione di Keycloak
extraStartupArgs: ''  # Argomenti aggiuntivi per l'avvio
enableDefaultInitContainers: true  # Abilita i container di inizializzazione predefiniti
initdbScripts: {}  # Script di inizializzazione del database
initdbScriptsConfigMap: ''  # ConfigMap con gli script di inizializzazione
command: []  # Comando personalizzato per il container
args: []  # Argomenti personalizzati per il container
extraEnvVars: []  # Variabili di ambiente aggiuntive
extraEnvVarsCM: ''  # ConfigMap con variabili di ambiente aggiuntive
extraEnvVarsSecret: ''  # Secret con variabili di ambiente aggiuntive

replicaCount: 1  # Numero di repliche di Keycloak
revisionHistoryLimitCount: 10  # Numero di revisioni da mantenere
containerPorts:
  http: 8080  # Porta HTTP del container
  https: 8443  # Porta HTTPS del container
  metrics: 9000  # Porta per le metriche
extraContainerPorts: []  # Porte aggiuntive per il container

statefulsetAnnotations: {}  # Annotazioni per lo StatefulSet (lascia vuoto se non necessarie)

podSecurityContext:
  enabled: true  # Abilita il contesto di sicurezza per i pod
  fsGroupChangePolicy: Always  # Politica di modifica del gruppo FS
  sysctls: []  # Parametri sysctl personalizzati (lascia vuoto se non necessari)
  supplementalGroups: []  # Gruppi supplementari (lascia vuoto se non necessari)
  fsGroup: 1001  # Gruppo FS per i volumi montati

containerSecurityContext:
  enabled: true  # Abilita il contesto di sicurezza per i container
  seLinuxOptions: {}  # Opzioni SELinux (lascia vuoto se non utilizzi SELinux)
  runAsUser: 1001  # UID dell'utente che esegue il container
  runAsGroup: 1001  # GID del gruppo che esegue il container
  runAsNonRoot: true  # Esegui come utente non root
  privileged: false  # Non eseguire il container come privilegiato
  readOnlyRootFilesystem: true  # Imposta il file system come di sola lettura
  allowPrivilegeEscalation: false  # Non consentire l'escalation dei privilegi
  capabilities:
    drop:
      - ALL  # Rimuovi tutte le capacità Linux
  seccompProfile:
    type: RuntimeDefault  # Usa il profilo Seccomp predefinito

resourcesPreset: small  # Preset per le risorse del container (es. small, medium, large)
resources:  # Richieste e limiti delle risorse (personalizza in base al tuo ambiente)
  requests:
    memory: "512Mi"  # Memoria richiesta
    cpu: "250m"  # CPU richiesta
  limits:
    memory: "1Gi"  # Limite massimo di memoria
    cpu: "500m"  # Limite massimo di CPU

livenessProbe:
  enabled: true  # Abilita il probe di liveness
  initialDelaySeconds: 300  # Ritardo iniziale
  periodSeconds: 1  # Frequenza del probe
  timeoutSeconds: 5  # Timeout del probe
  failureThreshold: 3  # Numero di fallimenti prima di considerare il container non funzionante
  successThreshold: 1  # Numero di successi richiesti

readinessProbe:
  enabled: true  # Abilita il probe di readiness
  initialDelaySeconds: 30  # Ritardo iniziale
  periodSeconds: 10  # Frequenza del probe
  timeoutSeconds: 1  # Timeout del probe
  failureThreshold: 3  # Numero di fallimenti prima di considerare il container non pronto
  successThreshold: 1  # Numero di successi richiesti

startupProbe:
  enabled: false  # Abilita il probe di startup
  initialDelaySeconds: 30  # Ritardo iniziale
  periodSeconds: 5  # Frequenza del probe
  timeoutSeconds: 1  # Timeout del probe
  failureThreshold: 60  # Numero di fallimenti prima di considerare il container non avviato
  successThreshold: 1  # Numero di successi richiesti

customLivenessProbe: {}  # Configurazione personalizzata per il probe di liveness
customReadinessProbe: {}  # Configurazione personalizzata per il probe di readiness
customStartupProbe: {}  # Configurazione personalizzata per il probe di startup
lifecycleHooks: {}  # Hook per il ciclo di vita del container
automountServiceAccountToken: true  # Monta automaticamente il token del service account
hostAliases: []  # Alias host personalizzati per i pod (lascia vuoto se non necessario)
podLabels:  # Etichette personalizzate per i pod
  app: keycloak
podAnnotations:  # Annotazioni personalizzate per i pod
  prometheus.io/scrape: 'true'  # Abilita il monitoraggio Prometheus
  prometheus.io/port: '8080'
podAffinityPreset: ''  # Preset per l'affinità dei pod (es. hard, soft)
podAntiAffinityPreset: soft  # Preset per l'anti-affinità dei pod (soft è consigliato per evitare conflitti)
nodeAffinityPreset:  # Preset per l'affinità dei nodi
  type: hard  # Tipo di affinità (es. hard, soft)
  key: kubernetes.io/hostname  # Chiave per l'affinità
  values:
    - node1  # Nome del nodo preferito
affinity: {}  # Configurazione avanzata per l'affinità (lascia vuoto se non necessario)
nodeSelector:  # Selettore dei nodi per la schedulazione
  disktype: ssd  # Esempio: seleziona nodi con dischi SSD
tolerations:  # Tolleranze per la schedulazione
  - key: "keycloak"
    operator: "Exists"
    effect: "NoSchedule"
topologySpreadConstraints: []  # Vincoli di distribuzione topologica (lascia vuoto se non necessario)
podManagementPolicy: Parallel  # Politica di gestione dei pod (Parallel o OrderedReady)
priorityClassName: ''  # Nome della classe di priorità (lascia vuoto se non necessario)
schedulerName: ''  # Nome dello scheduler personalizzato (lascia vuoto per usare quello predefinito)
terminationGracePeriodSeconds: 30  # Periodo di grazia per la terminazione dei pod
updateStrategy:  # Strategia di aggiornamento per i pod
  type: RollingUpdate  # Tipo di strategia (es. RollingUpdate, OnDelete)
  rollingUpdate:
    maxUnavailable: 1  # Numero massimo di pod non disponibili durante l'aggiornamento
    maxSurge: 1  # Numero massimo di pod aggiuntivi durante l'aggiornamento
minReadySeconds: 10  # Tempo minimo in cui un pod deve essere pronto prima di considerarlo disponibile
extraVolumes: []  # Volumi aggiuntivi per i pod (lascia vuoto se non necessario)
extraVolumeMounts: []  # Mount dei volumi aggiuntivi (lascia vuoto se non necessario)
initContainers: []  # Container di inizializzazione aggiuntivi (lascia vuoto se non necessario)
sidecars: []  # Sidecar container aggiuntivi (lascia vuoto se non necessario)

service:
  type: ClusterIP  # Tipo di servizio Kubernetes
  http:
    enabled: true  # Abilita il servizio HTTP
  ports:
    http: 80  # Porta HTTP del servizio
    https: 443  # Porta HTTPS del servizio
  nodePorts:
    http: ''  # NodePort per HTTP (lascia vuoto se non necessario)
    https: ''  # NodePort per HTTPS (lascia vuoto se non necessario)
  sessionAffinity: None  # Affinità di sessione (None o ClientIP)
  sessionAffinityConfig: {}  # Configurazione aggiuntiva per l'affinità di sessione
  clusterIP: ''  # ClusterIP del servizio (lascia vuoto per un IP assegnato automaticamente)
  loadBalancerIP: ''  # IP del LoadBalancer (lascia vuoto se non utilizzi un LoadBalancer)
  loadBalancerSourceRanges: []  # Intervalli di IP consentiti per il LoadBalancer
  externalTrafficPolicy: Cluster  # Politica del traffico esterno (Cluster o Local)
  annotations: {}  # Annotazioni per il servizio
  extraPorts: []  # Porte aggiuntive per il servizio
  extraHeadlessPorts: []  # Porte aggiuntive per il servizio headless
  headless:
    annotations: {}  # Annotazioni per il servizio headless
    extraPorts: []  # Porte aggiuntive per il servizio headless

ingress:
  enabled: true  # Abilita l'ingress
  ingressClassName: nginx  # Classe ingress
  pathType: ImplementationSpecific  # Tipo di path (es. Prefix, ImplementationSpecific)
  apiVersion: ''  # Lascia vuoto per utilizzare la versione predefinita dell'API ingress
  controller: default  # Controller dell'ingress
  hostname: keycloak.local  # Hostname per l'ingress
  hostnameStrict: false  # Non applicare un matching rigoroso dell'hostname
  path: '/'  # Percorso per l'ingress
  servicePort: http  # Porta del servizio per l'ingress
  annotations:  # Annotazioni per configurare il controller ingress e cert-manager
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"  # Protocollo backend
    cert-manager.io/cluster-issuer: "selfsigned-cluster-issuer"  # ClusterIssuer di cert-manager
    nginx.ingress.kubernetes.io/ssl-redirect: "true"  # Forza il redirect da HTTP a HTTPS
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"  # Configurazione aggiuntiva (opzionale)
  labels: {}  # Etichette aggiuntive per l'ingress
  tls: true  # Abilita TLS
  selfSigned: false  # Non generare certificati self-signed (gestiti da cert-manager)
  extraHosts: []  # Host aggiuntivi (lascia vuoto se non necessario)
  extraPaths: []  # Percorsi aggiuntivi (lascia vuoto se non necessario)
  extraTls:  # Configurazione TLS aggiuntiva
    - hosts:
        - keycloak.local
      secretName: keycloak-tls  # Nome del secret TLS creato da cert-manager
  secrets: []  # Lascia vuoto, cert-manager gestirà i certificati
  extraRules: []  # Regole aggiuntive per l'ingress (lascia vuoto se non necessario)

adminIngress:
  enabled: false
  ingressClassName: ''
  pathType: ImplementationSpecific
  apiVersion: ''
  controller: default
  hostname: keycloak.local
  path: '{{ .Values.httpRelativePath }}'
  servicePort: http
  annotations: {}
  labels: {}
  tls: false
  selfSigned: false
  extraHosts: []
  extraPaths: []
  extraTls: []
  secrets: []
  extraRules: []
networkPolicy:
  enabled: true
  allowExternal: true
  allowExternalEgress: true
  kubeAPIServerPorts:
    - 443
    - 6443
    - 8443
  extraIngress: []
  extraEgress: []
  ingressNSMatchLabels: {}
  ingressNSPodMatchLabels: {}
serviceAccount:
  create: true
  name: ''
  automountServiceAccountToken: false
  annotations: {}
  extraLabels: {}
rbac:
  create: false
  rules: []
pdb:
  create: true
  minAvailable: ''
  maxUnavailable: ''
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 11
  targetCPU: ''
  targetMemory: ''
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 120
      selectPolicy: Max
      policies: []
    scaleDown:
      stabilizationWindowSeconds: 300
      selectPolicy: Max
      policies:
        - type: Pods
          value: 1
          periodSeconds: 300
metrics:
  enabled: false
  service:
    ports:
      http: 8080
      https: 8443
      metrics: 9000
    annotations:
      prometheus.io/scrape: 'true'
      prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
    extraPorts: []
  serviceMonitor:
    enabled: false
    port: metrics
    scheme: http
    tlsConfig: {}
    endpoints:
      - path: '{{ include "keycloak.httpPath" . }}metrics'
      - path: >-
          {{ include "keycloak.httpPath" . }}realms/{{ .Values.adminRealm
          }}/metrics
        port: http
    path: ''
    namespace: ''
    interval: 30s
    scrapeTimeout: ''
    labels: {}
    selector: {}
    relabelings: []
    metricRelabelings: []
    honorLabels: false
    jobLabel: ''
  prometheusRule:
    enabled: false
    namespace: ''
    labels: {}
    groups: []
keycloakConfigCli:
  enabled: false
  image:
    registry: docker.io
    repository: bitnami/keycloak-config-cli
    tag: 6.4.0-debian-12-r5
    digest: ''
    pullPolicy: IfNotPresent
    pullSecrets: []
  annotations:
    helm.sh/hook: 'post-install,post-upgrade,post-rollback'
    helm.sh/hook-delete-policy: 'hook-succeeded,before-hook-creation'
    helm.sh/hook-weight: '5'
  command: []
  args: []
  automountServiceAccountToken: true
  hostAliases: []
  resourcesPreset: small
  resources: {}
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    seccompProfile:
      type: RuntimeDefault
  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001
  backoffLimit: 1
  podLabels: {}
  podAnnotations: {}
  nodeSelector: {}
  podTolerations: []
  availabilityCheck:
    enabled: true
    timeout: ''
  extraEnvVars: []
  extraEnvVarsCM: ''
  extraEnvVarsSecret: ''
  extraVolumes: []
  extraVolumeMounts: []
  initContainers: []
  sidecars: []
  configuration: {}
  existingConfigmap: ''
  cleanupAfterFinished:
    enabled: false
    seconds: 600
postgresql:
  enabled: true  # Abilita PostgreSQL interno
  auth:
    postgresPassword: ''
    username: bn_keycloak
    password: ''
    database: bitnami_keycloak
    existingSecret: ''
    secretKeys:
      userPasswordKey: password
  architecture: standalone
externalDatabase:
  host: ''  # Host del database esterno
  port: 5432  # Porta del database esterno
  user: bn_keycloak  # Nome utente del database esterno
  database: bitnami_keycloak  # Nome del database esterno
  password: ''  # Password del database esterno
  existingSecret: ''
  existingSecretHostKey: ''
  existingSecretPortKey: ''
  existingSecretUserKey: ''
  existingSecretDatabaseKey: ''
  existingSecretPasswordKey: ''
  annotations: {}
cache:
  enabled: true  # Abilita la cache
  stackName: kubernetes  # Nome dello stack della cache
  stackFile: ''
  useHeadlessServiceWithAppVersion: false
logging:
  output: default  # Output dei log
  level: INFO  # Livello di log